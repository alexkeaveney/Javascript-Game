<html>
    <head>
        <title>Howiya</title>
        <script src="../socket.io/socket.io.js"></script>
          <script src="adapter.js"></script>
        <style>
            #startButton, #bullshit, #localVideo, #skip, #claim  {
                display: none;
            }

            #remoteVideo {
                width: 480px;
                height: 360px;
                margin: 0 auto;
            }

            #videos, #messages {
                text-align: center;
                color: white;
                font-family: sans-serif;
            }

            #cardHolder {
                margin-top: 20px;
            }

            #turnButtons {
                margin: 0 auto;
                text-align: center;
            }

            #claim {
                margin-top: 20px;
                background-color: yellow;
                font-size: 14pt;
                border: 2px solid black;
                margin: 0 auto;
            }

            #skip {
                margin-top: 20px;
                background-color: blue;
                font-size: 14pt;
                border: 2px solid black;
                color: white;
                margin: 0 auto;
            }

            #bullshit {
                margin-top: 20px;
                background-color: red;
                color: white;
                font-size: 14pt;
                border: 2px solid black;
                margin: 0 auto;
            }

            body {
                background-color: green;
            }

        </style>
    </head>
    <body>
        <input type="text" id="username"><span id="error"></span>
        <button id="loginButton">Login</button>
        <button id="startButton">Start game</button>

        <p id="messages"></p>
        <div id="videos">
          <video id="localVideo" autoplay muted></video>
          <video id="remoteVideo" autoplay></video>
        </div>

        <div id="turnButtons">
            <button id="claim" onclick="claim()">Claim</button>
            <button id="skip" onclick="skip()">Skip turn</button>
        </div>

        <button id="bullshit" onclick="bullshit(true)">Bullshit</button>
        <div id="cardHolder"></div>


        <script>
            'use strict';

            var isChannelReady = false;
            var isInitiator = false;
            var isStarted = false;
            var localStream;
            var pc;
            var remoteStream;
            var turnReady;

            var pcConfig = {
              'iceServers': [{
                'urls': 'stun:stun.l.google.com:19302'
              }]
            };

            // Set up audio and video regardless of what devices are present.
            var sdpConstraints = {
              offerToReceiveAudio: true,
              offerToReceiveVideo: true
            };
            const socket = io.connect();
            const messages = document.getElementById('messages');
            const startButton = document.getElementById('startButton');
            let yourTurn = false;
            let turnCard = "";
            let cards = [];
            let selectedCards = [];
            let buttons = [];
            let name = "";
            let interval;

            startButton.addEventListener('click', function() {
                socket.emit('startGame', username);
                startButton.style.display = 'none';
                document.getElementById('cardHolder').style.display = 'block';
                document.getElementById('remoteVideo').style.display = 'block';
            });

            document.getElementById('loginButton').addEventListener('click', function() {

                const username = document.getElementById('username').value;

                if (username==="") {
                    document.getElementById('error').innerHTML = "You have not typed in a username";
                }
                else {
                    name = username;
                    socket.emit ('connectPlayer', username);
                    messages.innerHTML = "Player Connected";
                    document.getElementById('username').style.display = 'none';
                    document.getElementById('loginButton').style.display = 'none';
                    document.getElementById('startButton').style.display = 'block';
                }
            });

            socket.on('room', function(message) {
                  messages.innerHTML = message;
                  if (message=='new room created') {
                      isInitiator = true;

                  }
                  else {
                      isChannelReady = true;
                      console.log("is channel ready" + isChannelReady);
                      navigator.mediaDevices.getUserMedia({
                        audio: false,
                        video: true
                      })
                      .then(gotStream)
                      .catch(function(e) {
                        alert('getUserMedia() error: ' + e.name);
                      });
                  }
            });

            function sendMessage(message) {
                console.log('Client sending message: ', message);
                socket.emit('message', message);
            }

            // This client receives a message
            socket.on('message', function(message) {
              console.log('Client received message:', message);
              if (message === 'got user media') {
                maybeStart();
              } else if (message.type === 'offer') {
                if (!isInitiator && !isStarted) {
                  maybeStart();
                }
                pc.setRemoteDescription(new RTCSessionDescription(message));
                doAnswer();
              } else if (message.type === 'answer' && isStarted) {
                pc.setRemoteDescription(new RTCSessionDescription(message));
              } else if (message.type === 'candidate' && isStarted) {
                var candidate = new RTCIceCandidate({
                  sdpMLineIndex: message.label,
                  candidate: message.candidate
                });
                pc.addIceCandidate(candidate);
              } else if (message === 'bye' && isStarted) {
                handleRemoteHangup();
              }
            });

            ////////////////////////////////////////////////////

var localVideo = document.querySelector('#localVideo');
var remoteVideo = document.querySelector('#remoteVideo');

// navigator.mediaDevices.getUserMedia({
//   audio: false,
//   video: true
// })
// .then(gotStream)
// .catch(function(e) {
//   alert('getUserMedia() error: ' + e.name);
// });

function gotStream(stream) {
  console.log('Adding local stream.');
  localVideo.src = window.URL.createObjectURL(stream);
  localStream = stream;
  sendMessage('got user media');
  if (isInitiator) {
    maybeStart();
  }
}

var constraints = {
  video: true
};

console.log('Getting user media with constraints', constraints);

if (location.hostname !== 'localhost') {
  requestTurn(
    'https://computeengineondemand.appspot.com/turn?username=41784574&key=4080218913'
  );
}

function maybeStart() {
  console.log('>>>>>>> maybeStart() ', isStarted, localStream, isChannelReady);
    console.log("in maybe start function");
    console.log(isStarted);
    console.log(typeof(localStream));
    console.log(isChannelReady);
  if (!isStarted && typeof localStream !== 'undefined' && isChannelReady) {
    console.log('>>>>>> creating peer connection');
    createPeerConnection();
    pc.addStream(localStream);
    isStarted = true;
    console.log('isInitiator', isInitiator);
    if (isInitiator) {
      doCall();
    }
  }
}

// window.onbeforeunload = function() {
//   sendMessage('bye');
// };

/////////////////////////////////////////////////////////

function createPeerConnection() {
  try {
    pc = new RTCPeerConnection(null);
    pc.onicecandidate = handleIceCandidate;
    pc.onaddstream = handleRemoteStreamAdded;
    pc.onremovestream = handleRemoteStreamRemoved;
    console.log('Created RTCPeerConnnection');
  } catch (e) {
    console.log('Failed to create PeerConnection, exception: ' + e.message);
    alert('Cannot create RTCPeerConnection object.');
    return;
  }
}

function handleIceCandidate(event) {
  console.log('icecandidate event: ', event);
  if (event.candidate) {
    sendMessage({
      type: 'candidate',
      label: event.candidate.sdpMLineIndex,
      id: event.candidate.sdpMid,
      candidate: event.candidate.candidate
    });
  } else {
    console.log('End of candidates.');
  }
}

function handleCreateOfferError(event) {
  console.log('createOffer() error: ', event);
}

function doCall() {
  console.log('Sending offer to peer');
  pc.createOffer(setLocalAndSendMessage, handleCreateOfferError);
}

function doAnswer() {
  console.log('Sending answer to peer.');
  pc.createAnswer().then(
    setLocalAndSendMessage,
    onCreateSessionDescriptionError
  );
}

function setLocalAndSendMessage(sessionDescription) {
  // Set Opus as the preferred codec in SDP if Opus is present.
  //  sessionDescription.sdp = preferOpus(sessionDescription.sdp);
  pc.setLocalDescription(sessionDescription);
  console.log('setLocalAndSendMessage sending message', sessionDescription);
  sendMessage(sessionDescription);
}

function onCreateSessionDescriptionError(error) {
  trace('Failed to create session description: ' + error.toString());
}

function requestTurn(turnURL) {
  var turnExists = false;
  for (var i in pcConfig.iceServers) {
    if (pcConfig.iceServers[i].urls.substr(0, 5) === 'turn:') {
      turnExists = true;
      turnReady = true;
      break;
    }
  }
  if (!turnExists) {
    console.log('Getting TURN server from ', turnURL);
    // No TURN server. Get one from computeengineondemand.appspot.com:
    var xhr = new XMLHttpRequest();
    xhr.onreadystatechange = function() {
      if (xhr.readyState === 4 && xhr.status === 200) {
        var turnServer = JSON.parse(xhr.responseText);
        console.log('Got TURN server: ', turnServer);
        pcConfig.iceServers.push({
          'urls': 'turn:' + turnServer.username + '@' + turnServer.turn,
          'credential': turnServer.password
        });
        turnReady = true;
      }
    };
    xhr.open('GET', turnURL, true);
    xhr.send();
  }
}

function handleRemoteStreamAdded(event) {
  console.log('Remote stream added.');
  remoteVideo.src = window.URL.createObjectURL(event.stream);
  remoteStream = event.stream;
}

function handleRemoteStreamRemoved(event) {
  console.log('Remote stream removed. Event: ', event);
}

function hangup() {
  console.log('Hanging up.');
  stop();
  sendMessage('bye');
}

function handleRemoteHangup() {
  console.log('Session terminated.');
  stop();
  isInitiator = false;
}

function stop() {
  isStarted = false;
  pc.close();
  pc = null;
}

///////////////////////////////////////////

// Set Opus as the default audio codec if it's present.
function preferOpus(sdp) {
  var sdpLines = sdp.split('\r\n');
  var mLineIndex;
  // Search for m line.
  for (var i = 0; i < sdpLines.length; i++) {
    if (sdpLines[i].search('m=audio') !== -1) {
      mLineIndex = i;
      break;
    }
  }
  if (mLineIndex === null) {
    return sdp;
  }

  // If Opus is available, set it as the default in m line.
  for (i = 0; i < sdpLines.length; i++) {
    if (sdpLines[i].search('opus/48000') !== -1) {
      var opusPayload = extractSdp(sdpLines[i], /:(\d+) opus\/48000/i);
      if (opusPayload) {
        sdpLines[mLineIndex] = setDefaultCodec(sdpLines[mLineIndex],
          opusPayload);
      }
      break;
    }
  }

  // Remove CN in m line and sdp.
  sdpLines = removeCN(sdpLines, mLineIndex);

  sdp = sdpLines.join('\r\n');
  return sdp;
}

function extractSdp(sdpLine, pattern) {
  var result = sdpLine.match(pattern);
  return result && result.length === 2 ? result[1] : null;
}

// Set the selected codec to the first in m line.
function setDefaultCodec(mLine, payload) {
  var elements = mLine.split(' ');
  var newLine = [];
  var index = 0;
  for (var i = 0; i < elements.length; i++) {
    if (index === 3) { // Format of media starts from the fourth.
      newLine[index++] = payload; // Put target payload to the first.
    }
    if (elements[i] !== payload) {
      newLine[index++] = elements[i];
    }
  }
  return newLine.join(' ');
}

// Strip CN from sdp before CN constraints is ready.
function removeCN(sdpLines, mLineIndex) {
  var mLineElements = sdpLines[mLineIndex].split(' ');
  // Scan from end for the convenience of removing an item.
  for (var i = sdpLines.length - 1; i >= 0; i--) {
    var payload = extractSdp(sdpLines[i], /a=rtpmap:(\d+) CN\/\d+/i);
    if (payload) {
      var cnPos = mLineElements.indexOf(payload);
      if (cnPos !== -1) {
        // Remove CN payload from m line.
        mLineElements.splice(cnPos, 1);
      }
      // Remove CN line in sdp
      sdpLines.splice(i, 1);
    }
  }

  sdpLines[mLineIndex] = mLineElements.join(' ');
  return sdpLines;
}

            socket.on('cards', function(messages) {
                  let cardHolder = document.getElementById('cardHolder');
                  //messages.innerHTML = message;
                //   console.log(messages.hand);
                //   console.log(messages.hand[0].suit);
                //   console.log(messages.hand[0].rank);



                  for (let i =0; i < messages.hand.length; i++) {
                      let btn = document.createElement("BUTTON");
                    // Create a <button> element
                      let t = document.createTextNode(messages.hand[i].rank);
                      btn.setAttribute("id", `${messages.hand[i].rank}${messages.hand[i].suit}`);
                      btn.addEventListener('click', function() {
                          if (yourTurn) {
                             selectCard(`${messages.hand[i].rank}${messages.hand[i].suit}`);
                          }
                          clearInterval(interval);

                      });
                          // Create a text node
                      btn.appendChild(t);
                      let imageLink = `/images/${messages.hand[i].rank}_of_${messages.hand[i].suit.toLowerCase()}.png`;
                      btn.innerHTML = "<img height='80' width='50' src='" + imageLink + "'/>";
                      cards.push({
                         suit: messages.hand[i].suit,
                         rank: messages.hand[i].rank,
                         button: btn
                      });
                                            // Append the text to <button>
                      cardHolder.appendChild(btn);
                  }

                  yourTurn = messages.move;
                  console.log(yourTurn);
                  turnCard = messages.turnCard;
                  console.log(turnCard);

                  if (yourTurn) {
                      console.log("It is your turn to play " + turnCard + "'s");
                      document.getElementById('messages').innerHTML = "It is your turn to play " + turnCard + "'s";
                      document.getElementById('claim').style.display = 'inline';
                      document.getElementById('skip').style.display = 'inline';
                  }
                  else {
                      console.log("Its your opponents turn to play " + turnCard + "s");
                      document.getElementById('messages').innerHTML = "Its your opponents turn to play " + turnCard + "s";
                  }


            });

            socket.on('opponentmove', function(cards) {
                console.log(cards);
                let bullshitButton = document.getElementById('bullshit');
                bullshitButton.style.display = 'block';
                document.getElementById('messages').innerHTML = "Your opponent played " + cards.length + " " + turnCard + "s";

                let seconds = 5,
                second = 0;

                interval = setInterval(function() {
                console.log(seconds - second);
                let num = seconds - second;
                bullshitButton.innerHTML = `Bullshit(${num})`;
                if (second >= seconds) {
                    //bullshitButton.style.display = 'none';
                    bullshit(false);
                    clearInterval(interval);
                }
                second++;
                }, 1000);
            });

            socket.on('nobullshit', function(message) {
                console.log('no bullshit');
                console.log(message);
                console.log(message.whoseTurn);
                console.log("username===" + name);
                if (message.win=="none") {
                    if (message.whoseTurn == name) {
                        console.log("its your turn")
                        yourTurn = true;
                        turnCard = message.turnCard;
                        document.getElementById('messages').innerHTML = "It's your turn to play " + turnCard + "s";
                        document.getElementById('claim').style.display = 'inline';
                        document.getElementById('skip').style.display = "inline";
                    }
                    else {
                        yourTurn = false;
                        turnCard = message.turnCard;
                        document.getElementById('messages').innerHTML = "It's your opponents turn to play " + turnCard + "s";
                    }
                }
                else if (message.win == name) {
                    document.getElementById('messages').innerHTML = "You win";
                    //hangs up the call
                    removeGameElements();
                    socket.emit('message', 'bye');
                    socket.emit('endgame', name);
                }
                else {
                    document.getElementById('messages').innerHTML = "You lose";
                    //hangs up the call
                    cards = [];
                    let cardHolder = document.getElementById('cardHolder');
                    while (cardHolder.firstChild) {
                        cardHolder.removeChild(cardHolder.firstChild);
                    }

                    removeGameElements();
                    socket.emit('message', 'bye');
                }



            });

            socket.on('handresult', function(message) {
                console.log(message.result);
                console.log("Your turn = " + message.yourTurn);
                document.getElementById('messages').innerHTML = message.result;
                yourTurn = message.yourTurn;
                turnCard = message.turnCard;

                //no one won - continue game
                if (message.win == "none") {
                    if (yourTurn) {
                        document.getElementById('messages').innerHTML = "It is your turn to play " + message.turnCard + "'s";
                        document.getElementById('claim').style.display = 'inline';
                        document.getElementById('skip').style.display = 'inline';

                    }
                    else {
                        document.getElementById('messages').innerHTML = "Its your opponents turn to play " + message.turnCard + "s";
                    }

                    //clear cards
                    resetHand(message.cards);
                }

                //you won
                else if(message.win == name) {
                    alert("You win!");
                    //hangs up the call
                    socket.emit('message', 'bye');
                    removeGameElements();
                    socket.emit('endgame', name);
                }

                //your opponent one
                else {
                    alert("You lose!");
                    //hangs up the call
                    cards = [];
                    let cardHolder = document.getElementById('cardHolder');
                    while (cardHolder.firstChild) {
                        cardHolder.removeChild(cardHolder.firstChild);
                    }
                    removeGameElements();
                    socket.emit('message', 'bye');
                }




            });

            function removeGameElements() {
                document.getElementById('remoteVideo').style.display = 'none';
                document.getElementById('cardHolder').style.display = 'none';
            }

            socket.on('skipturn', function(message) {
                if (message.yourTurn) {
                    yourTurn = true;
                    turnCard = message.turnCard;
                    document.getElementById('messages').innerHTML = "It's your turn to play " + turnCard + "s";
                    document.getElementById('claim').style.display = 'inline';
                    document.getElementById('skip').style.display = "inline";
                }
                else {
                    yourTurn = false;
                    turnCard = message.turnCard;
                    document.getElementById('messages').innerHTML = "It's your opponents turn to play " + turnCard + "s";
                }
            });

            function resetHand(hand) {
                let holder = document.getElementById('cardHolder');
                for (let i = 0; i < cards.length; i++) {
                    holder.removeChild(cards[i].button);
                }

                //empty cards array
                cards = [];

                for (let i = 0; i < hand.length; i++) {
                    let btn = document.createElement("BUTTON");
                  // Create a <button> element
                    let t = document.createTextNode(hand[i].rank);
                    btn.setAttribute("id", `${hand[i].rank}${hand[i].suit}`);
                    btn.addEventListener('click', function() {
                        if (yourTurn) {
                           selectCard(`${hand[i].rank}${hand[i].suit}`);
                        }
                        clearInterval(interval);
                    });
                        // Create a text node
                    btn.appendChild(t);
                    let imageLink = `/images/${hand[i].rank}_of_${hand[i].suit.toLowerCase()}.png`;
                    btn.innerHTML = "<img height='80' width='50' src='" + imageLink + "'/>";
                    cards.push({
                       suit: hand[i].suit,
                       rank: hand[i].rank,
                       button: btn
                    });
                    // Append the text to <button>
                    cardHolder.appendChild(btn);
                }

            }

            function bullshit(bool) {
                console.log("bullshit funciton started");
                socket.emit('bullshit', bool);
                document.getElementById('bullshit').style.display = 'none';
            }

            function skip() {

                document.getElementById('claim').style.display = 'none';
                document.getElementById('skip').style.display = 'none';
                socket.emit('skipmove', true);
                console.log("turn skipped");
            }

            function claim() {
                if (selectedCards.length > 0) {
                    document.getElementById('claim').style.display = 'none';
                    document.getElementById('skip').style.display = 'none';
                    document.getElementById('messages').innerHTML = "Waiting on opponents response...";

                    let selectedObjects = [];
                    for (let i =0; i < selectedCards.length; i++) {
                        for (let x =0; x < cards.length; x++) {
                            if (selectedCards[i].includes(cards[x].rank) && selectedCards[i].includes(cards[x].suit)) {
                                selectedObjects.push(cards[x]);
                                cardHolder.removeChild(cards[x].button);
                                cards.splice(x, 1);
                            }
                        }
                    }
                    //empty selected cards
                    selectedCards = [];

                    //send selected messages to server
                    socket.emit('playerMove', selectedObjects);
                }
                else {
                    document.getElementById('messages').innerHTML = "You must select atleast 1 card";
                }
                //remove the cards from players hand
            }

            function selectCard(card) {

                let alreadySelected = false;
                for (let i = 0; i < selectedCards.length; i++) {
                    console.log(card);
                    if (card == selectedCards[i]) {
                        alreadySelected = true;
                        console.log("already selected");
                    }
                }
                if (alreadySelected) {
                    //unselect it
                    const index = selectedCards.indexOf(card);
                    selectedCards.splice(index, 1);
                    document.getElementById(card).style.background = 'white';
                    console.log(selectedCards);
                }

                if (selectedCards.length < 4 || name == 'a') {
                    if (!alreadySelected) {
                        selectedCards.push(card);
                        document.getElementById(card).style.background = '#2ecc71';
                        console.log(selectedCards);
                    }
                }
                else {
                    document.getElementById('messages').innerHTML = "You cannot select more than 4 cards";
                }


            }

            socket.on('gameOver', function(winner) {
                console.log("GAME OVER!!!!!!");
                document.getElementById('startButton').style.display = 'block';
                document.getElementById('messages').innerHTML = "Game over press the start button to start a new game";

            });
        </script>


    </body>
</html>
